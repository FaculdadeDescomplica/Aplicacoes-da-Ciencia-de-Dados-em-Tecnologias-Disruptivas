# -*- coding: utf-8 -*-
"""Aplicações da Ciência de Dados em Tecnologias Disruptivas - Módulo 5

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1eEzPZ1h9YZDFWALqCMh2SB_A4rHe-HV3

KCF no Google Colab
"""

# Instalar o OpenCV com contrib modules (necessário para o KCF tracker e outros rastreadores)
!pip install opencv-python opencv-contrib-python

# Importar bibliotecas necessárias
import cv2
from google.colab import files
from google.colab.patches import cv2_imshow

# Fazer o upload do vídeo
uploaded = files.upload()

# Verificar se o arquivo foi carregado
if len(uploaded) > 0:
    video_path = list(uploaded.keys())[0]  # Obter o nome do arquivo carregado
else:
    print("Erro: Nenhum vídeo foi carregado.")

# Abrir o vídeo
cap = cv2.VideoCapture(video_path)

# Verifica se o vídeo foi aberto corretamente
if not cap.isOpened():
    print("Erro ao abrir o vídeo.")
else:
    # Ler o primeiro frame do vídeo
    ret, frame = cap.read()

    if not ret:
        print("Erro ao ler o primeiro frame do vídeo.")
    else:
        # Definir manualmente a ROI (bounding box)
        # Tente ajustar as coordenadas (x, y, largura, altura) conforme necessário
        bbox = (80, 60, 150, 150)  # Ajuste conforme necessário para o objeto no primeiro frame

        # Inicializar o rastreador KCF
        tracker = cv2.TrackerKCF_create()
        tracker.init(frame, bbox)

        # Loop para rastrear o objeto nos frames subsequentes
        while True:
            ret, frame = cap.read()

            if not ret:
                print("Fim do vídeo ou erro ao ler o frame.")
                break

            # Atualizar a posição do objeto rastreado
            ret, bbox = tracker.update(frame)

            if ret:
                # Desenhar a bounding box ao redor do objeto rastreado
                p1 = (int(bbox[0]), int(bbox[1]))
                p2 = (int(bbox[0] + bbox[2]), int(bbox[1] + bbox[3]))
                cv2.rectangle(frame, p1, p2, (255, 0, 0), 2, 1)
            else:
                # Caso o rastreamento falhe
                cv2.putText(frame, "Falhou", (100, 80), cv2.FONT_HERSHEY_SIMPLEX, 0.75, (0, 0, 255), 2)

            # Exibir o frame com o objeto rastreado
            cv2_imshow(frame)

        # Libera o vídeo ao final do processamento
        cap.release()
        cv2.destroyAllWindows()

"""Comparação do KCF com Outros Algoritmos"""

# Instalar o OpenCV com contrib modules (necessário para KCF e CSRT)
!pip install opencv-python opencv-contrib-python

# Importar bibliotecas necessárias
import cv2
import time  # Corrigido: Importar a biblioteca time
from google.colab import files
from google.colab.patches import cv2_imshow

# Fazer o upload do vídeo
uploaded = files.upload()

# Verificar se o arquivo foi carregado
if len(uploaded) > 0:
    video_path = list(uploaded.keys())[0]  # Obter o nome do arquivo carregado
else:
    print("Erro: Nenhum vídeo foi carregado.")

# Abrir o vídeo
cap = cv2.VideoCapture(video_path)

# Verifica se o vídeo foi aberto corretamente
if not cap.isOpened():
    print("Erro ao abrir o vídeo.")
else:
    # Ler o primeiro frame do vídeo
    ret, frame = cap.read()

    if not ret:
        print("Erro ao ler o primeiro frame do vídeo.")
    else:
        # Definir manualmente a ROI (bounding box)
        # Ajuste as coordenadas (x, y, largura, altura) conforme necessário
        bbox = (100, 100, 150, 150)  # Exemplo de ROI ajustada manualmente

        ### Rastreamento com KCF ###
        tracker_kcf = cv2.TrackerKCF_create()
        tracker_kcf.init(frame, bbox)

        # Medir o tempo do KCF
        start_kcf = time.time()
        ret_kcf, bbox_kcf = tracker_kcf.update(frame)
        end_kcf = time.time()

        # Desenhar a bounding box ao redor do objeto rastreado pelo KCF
        if ret_kcf:
            p1_kcf = (int(bbox_kcf[0]), int(bbox_kcf[1]))
            p2_kcf = (int(bbox_kcf[0] + bbox_kcf[2]), int(bbox_kcf[1] + bbox_kcf[3]))
            cv2.rectangle(frame, p1_kcf, p2_kcf, (255, 0, 0), 2, 1)
            print(f"Tempo de execução do KCF: {end_kcf - start_kcf:.4f} segundos")
            print("Exibindo o primeiro frame com KCF...")
            cv2_imshow(frame)
        else:
            print("Falha no rastreamento KCF.")

        # Ler novamente o primeiro frame para o CSRT
        cap.set(cv2.CAP_PROP_POS_FRAMES, 0)
        ret, frame = cap.read()

        ### Rastreamento com CSRT ###
        tracker_csrt = cv2.TrackerCSRT_create()
        tracker_csrt.init(frame, bbox)

        # Medir o tempo do CSRT
        start_csrt = time.time()
        ret_csrt, bbox_csrt = tracker_csrt.update(frame)
        end_csrt = time.time()

        # Desenhar a bounding box ao redor do objeto rastreado pelo CSRT
        if ret_csrt:
            p1_csrt = (int(bbox_csrt[0]), int(bbox_csrt[1]))
            p2_csrt = (int(bbox_csrt[0] + bbox_csrt[2]), int(bbox_csrt[1] + bbox_csrt[3]))
            cv2.rectangle(frame, p1_csrt, p2_csrt, (0, 255, 0), 2, 1)
            print(f"Tempo de execução do CSRT: {end_csrt - start_csrt:.4f} segundos")
            print("Exibindo o primeiro frame com CSRT...")
            cv2_imshow(frame)
        else:
            print("Falha no rastreamento CSRT.")

        # Libera o vídeo ao final do processamento
        cap.release()
        cv2.destroyAllWindows()